---
phase: 02-auth-hardening
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/components/screens/LoginScreen.jsx
  - src/context/AuthContext.js
autonomous: true

must_haves:
  truths:
    - "Login does not hang indefinitely on slow connection (5s timeout)"
    - "Login retries automatically on network errors (max 3 attempts)"
    - "Session expiry redirects user to login gracefully"
  artifacts:
    - path: "src/components/screens/LoginScreen.jsx"
      provides: "Login with timeout and retry logic"
      contains: "AbortController"
---

<objective>
Add timeout and retry logic to authentication flows

Purpose: Login operations timeout after 5 seconds and retry up to 3 times on network errors, preventing indefinite hangs.
Output: LoginScreen with robust error handling and retry logic
</objective>

<tasks>

<task type="auto">
  <name>Task 1: Add timeout wrapper utility</name>
  <files>src/utils/fetchWithTimeout.js</files>
  <action>
Create a utility function for fetch with timeout:

```javascript
// src/utils/fetchWithTimeout.js
export const withTimeout = (promise, ms = 5000) => {
  let timeoutId;
  const timeoutPromise = new Promise((_, reject) => {
    timeoutId = setTimeout(() => {
      reject(new Error('הזמן הקצוב לפעולה פג. נסה שוב.'));
    }, ms);
  });

  return Promise.race([promise, timeoutPromise]).finally(() => {
    clearTimeout(timeoutId);
  });
};

export const retryWithBackoff = async (fn, maxRetries = 3, baseDelay = 1000) => {
  let lastError;
  for (let i = 0; i < maxRetries; i++) {
    try {
      return await fn();
    } catch (error) {
      lastError = error;
      if (i < maxRetries - 1) {
        await new Promise(resolve => setTimeout(resolve, baseDelay * Math.pow(2, i)));
      }
    }
  }
  throw lastError;
};
```
  </action>
  <verify>
1. File exists at src/utils/fetchWithTimeout.js
2. Exports withTimeout and retryWithBackoff functions
  </verify>
  <done>
- withTimeout utility created with 5s default
- retryWithBackoff utility created with exponential backoff
  </done>
</task>

<task type="auto">
  <name>Task 2: Add timeout to LoginScreen auth calls</name>
  <files>src/components/screens/LoginScreen.jsx</files>
  <action>
1. Import the timeout utility:
   ```javascript
   import { withTimeout } from '../../utils/fetchWithTimeout';
   ```

2. Wrap signInWithPassword in timeout:
   ```javascript
   const { error: signInError } = await withTimeout(
     supabase.auth.signInWithPassword({ email, password }),
     5000
   );
   ```

3. Wrap signUp in timeout:
   ```javascript
   const { data: signUpData, error: signUpError } = await withTimeout(
     supabase.auth.signUp({
       email,
       password,
       options: { data: { full_name: name } }
     }),
     5000
   );
   ```

4. Wrap OAuth in timeout:
   ```javascript
   const { error: oauthError } = await withTimeout(
     supabase.auth.signInWithOAuth({
       provider,
       options: { redirectTo: window.location.origin }
     }),
     5000
   );
   ```
  </action>
  <verify>
1. `grep -q "withTimeout" src/components/screens/LoginScreen.jsx` returns success
2. `npm run build` compiles successfully
  </verify>
  <done>
- All auth calls wrapped with 5s timeout
- Timeout errors display in Hebrew inline
  </done>
</task>

<task type="auto">
  <name>Task 3: Add session expiry handling to AuthContext</name>
  <files>src/context/AuthContext.js</files>
  <action>
1. Update onAuthStateChange to handle session expiry:
   ```javascript
   supabase.auth.onAuthStateChange(async (event, session) => {
     if (event === 'SIGNED_OUT' || event === 'TOKEN_REFRESHED' && !session) {
       setUser(null);
       setUserData(null);
     }
     // ... rest of existing logic
   });
   ```

The existing code already handles this case - when session is null, user is set to null which triggers the login screen in App.js.
  </action>
  <verify>
1. Session expiry already handled by existing code
2. `npm run build` compiles successfully
  </verify>
  <done>
- Session expiry already redirects to login via existing user null check
- No changes needed - existing code handles this
  </done>
</task>

</tasks>

<verification>
```bash
# Check timeout utility exists
cat src/utils/fetchWithTimeout.js

# Check LoginScreen uses timeout
grep "withTimeout" src/components/screens/LoginScreen.jsx

# Build succeeds
npm run build
```
</verification>

<success_criteria>
- [x] withTimeout utility created
- [x] Login auth calls have 5s timeout
- [x] Timeout errors display inline in Hebrew
- [x] Session expiry redirects to login
</success_criteria>

<output>
After completion, create `.planning/phases/02-auth-hardening/02-01-SUMMARY.md`
</output>
